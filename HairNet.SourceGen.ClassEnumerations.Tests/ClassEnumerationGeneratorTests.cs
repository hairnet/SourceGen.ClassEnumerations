using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace HairNet.SourceGen.ClassEnumerations.Tests;

public class ClassEnumerationGeneratorTests
{
    private const string ClassEnumerationText = $@"
using HairNet.SourceGen.ClassEnumerations;

namespace TestNamespace;

[ClassEnumerations]
public interface IPrerequisite
{{
    public bool IsMet(Environment env)
}}

public class OSPrerequisite : IPrerequisite
{{
    public bool IsMet(Environment env)
    {{
        return env.OSVersion.StartsWith(""Unix"");
    }}
}}

public class BitnessPrerequisite : IPrerequisite
{{
    public bool IsMet(Environment env)
    {{
        return env.Is64BitOperatingSystem;
    }}
}}

public class XdgRuntimePrerequisite : IPrerequisite
{{
    public bool IsMet(Environment env)
    {{
        return !string.IsNullOrEmpty(env.GetEnvironmentVariable(""XDG_RUNTIME_DIR""));
    }}
}}
";

    private const string ExpectedGeneratedClassText = @"// <auto-generated/>

using System;
using System.Linq;
using System.Collections.Generic;

namespace TestNamespace;

public partial class PrerequisiteEnumeration : IEquatable<PrerequisiteEnumeration>
{
    public static readonly PrerequisiteEnumeration Empty = new(0);
	public static readonly PrerequisiteEnumeration BitnessPrerequisite = new(1);
	public static readonly PrerequisiteEnumeration OSPrerequisite = new(2);
	public static readonly PrerequisiteEnumeration XdgRuntimePrerequisite = new(4);
  
    private static readonly Dictionary<Type, string> ClassMap = new()
    {
		{typeof(BitnessPrerequisite), nameof(BitnessPrerequisite)},
		{typeof(OSPrerequisite), nameof(OSPrerequisite)},
		{typeof(XdgRuntimePrerequisite), nameof(XdgRuntimePrerequisite)},               
    }; 
         
    private static readonly Dictionary<string, int> FlagMap = new()
    {
        {""Empty"", 0},
		{nameof(BitnessPrerequisite), 1},
		{nameof(OSPrerequisite), 2},
		{nameof(XdgRuntimePrerequisite), 4},               
    };
    
    public static PrerequisiteEnumeration Full = new PrerequisiteEnumeration(FlagMap.Values.Aggregate(0, (all, cur) => all | cur));
                       
    private readonly int Value;

    private PrerequisiteEnumeration(int value)
    {
        Value = value;
    }
   
    public static PrerequisiteEnumeration FromPrerequisites(params IPrerequisite[] flags)
    {
        return new PrerequisiteEnumeration(flags.Aggregate(0, (x, next) => x |= FlagMap[ClassMap[next.GetType()]]));
    }
   
    public PrerequisiteEnumeration Inverse()
    {
        var v = Full.Value & (~Value);
        return new PrerequisiteEnumeration(v);
    }
    
    public PrerequisiteEnumeration SetFlags(params PrerequisiteEnumeration[] flags)
    {
        var i = Value;
        foreach (var flag in flags)
        {
            i |= flag.Value;
        }
        return new PrerequisiteEnumeration(i);
     }
  
    public PrerequisiteEnumeration UnsetFlags(params PrerequisiteEnumeration[] flags)
    {
        var i = Value;
        foreach (var flag in flags)
        {
            i &= ~flag.Value;
        }
        return new PrerequisiteEnumeration(i);
    }
  
    public bool HasFlags(params PrerequisiteEnumeration[] flags)
    {
        var combinedValue = flags.Aggregate(0, (current, flag) => current | flag.Value);
        return (Value & combinedValue) == combinedValue;
    }
  
    public bool LacksFlags(params PrerequisiteEnumeration[] flags)
    {
        var combinedValue = flags.Aggregate(0, (current, flag) => current | flag.Value);
        return (Value & combinedValue) == 0;
    }
  
    public static PrerequisiteEnumeration CombineFlags(params PrerequisiteEnumeration[] flags)
    {
        var combinedValue = flags.Aggregate(0, (current, flag) => current | flag.Value);
        return new PrerequisiteEnumeration(combinedValue);
    }
    
    public static Dictionary<string, Type> AllValues()
    {
        return ClassMap.ToDictionary(x => x.Value, x => x.Key);
    }
     
    public override string ToString()
    {
        var flagNames = GetFlagNames();
        return string.Join("", "", flagNames);
    }
  
    public IEnumerable<string> GetFlagNames()
    {
        return (FlagMap.Keys.Select(flagName => new {flagName, flagValue = FlagMap[flagName]})
            .Where(@t => (Value & @t.flagValue) != 0)
            .Select(@t => @t.flagName)).ToList();
    }
    
    public bool Equals(PrerequisiteEnumeration other)
    {
        return Value == other.Value;
    }
    
    public override bool Equals(object obj)
    {
        return this.Equals(obj as PrerequisiteEnumeration);
    }
    
    public override int GetHashCode()
    {
        return Value;
    }
}";

    [Fact]
    public void GenerateClassEnumerationMethod()
    {
        // Arrange
        var generator = new ClassEnumerationGenerator();
        var driver = CSharpGeneratorDriver.Create(generator);

        var compilation = CSharpCompilation.Create(nameof(ClassEnumerationGeneratorTests),
            new[] {CSharpSyntaxTree.ParseText(ClassEnumerationText)},
            new[]
            {
                // To support 'System.Attribute' inheritance, add reference to 'System.Private.CoreLib'.
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location)
            });

        // Act
        var runResult = driver.RunGenerators(compilation).GetRunResult();
        var generatedFileSyntax =
            runResult.GeneratedTrees.Single(t => t.FilePath.EndsWith("PrerequisiteEnumeration.g.cs"));
        var generatedText = generatedFileSyntax.GetText().ToString();
        
        // Assert
        Assert.Equal(ExpectedGeneratedClassText, generatedText, ignoreLineEndingDifferences: true);
}
}